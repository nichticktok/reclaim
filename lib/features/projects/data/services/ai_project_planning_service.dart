import 'dart:convert';
import 'package:flutter/foundation.dart' show debugPrint;
import 'package:flutter_gemini/flutter_gemini.dart';
import '../../../../app/env.dart';
import '../../domain/entities/project_planning_input.dart';
import '../../domain/repositories/ai_planning_repository.dart';
import '../../domain/entities/project_plan.dart';
import '../../../../core/models/plan_model.dart';

/// AI Project Planning Service
/// Uses Flutter Gemini SDK to generate project plans dynamically based on user input
/// All plans are generated by AI - no hardcoded templates
class AIProjectPlanningService implements AIPlanningRepository {
  // ============================================================================
  // API KEY CONFIGURATION
  // ============================================================================
  // IMPORTANT: For security, API keys should NEVER be hardcoded in source code.
  // Use environment variables instead:
  // Run with: flutter run --dart-define=GEMINI_API_KEY=your_key_here
  // Get your API key from: https://makersuite.google.com/app/apikey
  // ============================================================================

  /// Get API key for initialization (public static method)
  /// Used by main.dart to initialize Gemini
  /// API key must be provided via --dart-define=GEMINI_API_KEY=your_key
  static String getApiKey() {
    return AppEnv.geminiApiKey;
  }

  static String _getApiKey() {
    return getApiKey();
  }

  @override
  Future<ProjectPlan> generateProjectPlan(ProjectPlanningInput input) async {
    final apiKey = _getApiKey();
    if (apiKey.isEmpty) {
      throw Exception(
        'Gemini API key is not configured.\n\n'
        'Please set it using environment variables:\n'
        'Run with: flutter run --dart-define=GEMINI_API_KEY=your_key_here\n\n'
        'Get your API key from: https://makersuite.google.com/app/apikey\n\n'
        'Make sure Gemini.init() is called in main.dart!'
      );
    }

    // Gemini should be initialized in main.dart, but verify
    try {
      Gemini.instance;
    } catch (e) {
      // If not initialized, initialize it now
      Gemini.init(apiKey: apiKey, enableDebugging: false);
    }

    final prompt = _buildPrompt(input);
    final response = await _callGeminiAPI(prompt);
    return _parseProjectPlan(response);
  }

  /// Generate a PlanModel with daily plans using AI
  /// This method generates both phases and day-by-day schedule in a single API call
  Future<PlanModel> generateDailyPlan(
    ProjectPlanningInput input,
    String userId,
  ) async {
    final apiKey = _getApiKey();
    if (apiKey.isEmpty) {
      throw Exception(
        'Gemini API key is not configured.\n\n'
        'Please set it using environment variables:\n'
        'Run with: flutter run --dart-define=GEMINI_API_KEY=your_key_here\n\n'
        'Get your API key from: https://makersuite.google.com/app/apikey\n\n'
        'Make sure Gemini.init() is called in main.dart!'
      );
    }

    // Gemini should be initialized in main.dart, but verify
    try {
      Gemini.instance;
    } catch (e) {
      // If not initialized, initialize it now
      Gemini.init(apiKey: apiKey, enableDebugging: false);
    }

    // Generate both phases and daily plans in a single API call
    final prompt = _buildPrompt(input);
    final response = await _callGeminiAPI(prompt);
    
    // Parse daily plans from the single response
    final dailyPlans = _parseDailyPlansFromCompleteResponse(response, input);
    
    return PlanModel(
      id: '',
      userId: userId,
      projectTitle: input.title,
      description: input.description,
      category: input.category,
      startDate: input.startDate,
      endDate: input.endDate,
      hoursPerDay: input.hoursPerDay,
      dailyPlans: dailyPlans,
      createdAt: DateTime.now(),
    );
  }

  /// Parse daily plans from a complete response that contains both phases and dailyPlans
  List<DailyPlan> _parseDailyPlansFromCompleteResponse(String responseText, ProjectPlanningInput input) {
    try {
      // Extract JSON from response
      String jsonText = _extractJsonFromResponse(responseText);
      final json = jsonDecode(jsonText) as Map<String, dynamic>;
      
      // Handle nested project_plan structure
      Map<String, dynamic> rootJson = json;
      if (json.containsKey('project_plan') && json['project_plan'] is Map) {
        rootJson = json['project_plan'] as Map<String, dynamic>;
      } else if (json.containsKey('plan') && json['plan'] is Map) {
        rootJson = json['plan'] as Map<String, dynamic>;
      }
      
      // Try to find dailyPlans in the response
      List<dynamic>? dailyPlansJson;
      
      if (rootJson.containsKey('dailyPlans')) {
        dailyPlansJson = rootJson['dailyPlans'] as List<dynamic>?;
      } else if (rootJson.containsKey('schedule')) {
        dailyPlansJson = rootJson['schedule'] as List<dynamic>?;
      } else if (rootJson.containsKey('days')) {
        dailyPlansJson = rootJson['days'] as List<dynamic>?;
      } else if (json.containsKey('dailyPlans')) {
        dailyPlansJson = json['dailyPlans'] as List<dynamic>?;
      }
      
      if (dailyPlansJson != null && dailyPlansJson.isNotEmpty) {
        // Parse the daily plans array
        return _parseDailyPlansArray(dailyPlansJson, input);
      }
      
      // If no daily plans found, return empty list
      // The UI can still show phases even without daily breakdown
      return [];
    } catch (e) {
      debugPrint('⚠️ Warning: Could not parse daily plans from response: $e');
      // Return empty list on error, phases will still be shown
      return [];
    }
  }
  
  /// Parse an array of daily plan objects
  List<DailyPlan> _parseDailyPlansArray(List<dynamic> dailyPlansJson, ProjectPlanningInput input) {
    return dailyPlansJson.map((planJson) {
      final plan = planJson is Map<String, dynamic> 
          ? planJson 
          : Map<String, dynamic>.from(planJson as Map);
      
      // Parse date - handle different formats
      String dateStr = plan['date'] as String? ?? plan['day'] as String? ?? '';
      DateTime date;
      
      if (dateStr.contains('-')) {
        final dateParts = dateStr.split('-');
        date = DateTime(
          int.parse(dateParts[0]),
          int.parse(dateParts[1]),
          int.parse(dateParts[2]),
        );
      } else {
        // Use start date as fallback and increment based on index
        final index = dailyPlansJson.indexOf(planJson);
        date = input.startDate.add(Duration(days: index));
      }
      
      // Get tasks - handle different field names
      List<dynamic> tasksJson = [];
      if (plan.containsKey('tasks')) {
        tasksJson = plan['tasks'] as List<dynamic>;
      } else if (plan.containsKey('items')) {
        tasksJson = plan['items'] as List<dynamic>;
      } else if (plan.containsKey('todo')) {
        tasksJson = plan['todo'] as List<dynamic>;
      }
      
      final tasks = tasksJson.asMap().entries.map((entry) {
        final taskJson = entry.value is Map<String, dynamic>
            ? entry.value as Map<String, dynamic>
            : Map<String, dynamic>.from(entry.value as Map);
        
        // Handle different field names for hours
        double hours = 1.0;
        if (taskJson.containsKey('estimatedHours')) {
          hours = (taskJson['estimatedHours'] as num).toDouble();
        } else if (taskJson.containsKey('estimated_hours')) {
          hours = (taskJson['estimated_hours'] as num).toDouble();
        } else if (taskJson.containsKey('hours')) {
          hours = (taskJson['hours'] as num).toDouble();
        } else if (taskJson.containsKey('time')) {
          hours = (taskJson['time'] as num).toDouble();
        }
        
        return DailyTask(
          title: taskJson['title'] as String? 
              ?? taskJson['task_title'] as String?
              ?? taskJson['name'] as String? 
              ?? 'Untitled Task',
          description: taskJson['description'] as String? 
              ?? taskJson['desc'] as String? 
              ?? '',
          estimatedHours: hours,
          order: entry.key,
          phase: taskJson['phase'] as String? 
              ?? taskJson['category'] as String?,
        );
      }).toList();
      
      // Calculate total hours if not provided
      double totalHours = plan['totalHours'] as double? ?? 
          plan['hours'] as double? ?? 
          tasks.fold(0.0, (sum, task) => sum + task.estimatedHours);
      
      return DailyPlan(
        date: date,
        tasks: tasks,
        totalHours: totalHours,
        notes: plan['notes'] as String? 
            ?? plan['description'] as String? 
            ?? '',
      );
    }).toList();
  }

  String _buildPrompt(ProjectPlanningInput input) {
    final totalDays = input.totalDays;
    final totalHours = input.totalAvailableHours;
    final startDateStr = input.startDate.toString().split(' ')[0];
    final endDateStr = input.endDate.toString().split(' ')[0];

    return '''
You are an expert project planning assistant. Create a comprehensive, personalized project plan with day-by-day breakdown based on the following project details:

PROJECT INFORMATION:
- Title: ${input.title}
- Description: ${input.description}
- Category: ${input.category}
- Timeline: $startDateStr to $endDateStr ($totalDays days)
- Available Time: ${totalHours.toStringAsFixed(1)} total hours (${input.hoursPerDay} hours per day)

YOUR TASK:
Create a complete project plan that includes:
1. PHASES AND TASKS: Break down the project into phases and tasks
   - Decide how many phases are needed
   - Name each phase appropriately
   - List tasks within each phase
   - Each task should have: title, description, estimated hours

2. DAY-BY-DAY SCHEDULE: Create a detailed daily schedule
   - Start from $startDateStr and go through $endDateStr
   - Each day should have:
     * Date (YYYY-MM-DD format)
     * List of tasks to work on that day
     * Total hours for the day (should not exceed ${input.hoursPerDay} hours)
     * Notes/description for what to focus on that day
   - Distribute all tasks across the days intelligently
   - Consider pacing, task dependencies, and learning curves
   - Include buffer/rest days where appropriate
   - Group related tasks on the same day when it makes sense

IMPORTANT GUIDELINES:
- Make it realistic and achievable for this specific project
- Total estimated hours across all tasks should be close to ${totalHours.toStringAsFixed(1)} hours
- Tasks should be specific and actionable
- Consider the project category (${input.category}) when structuring
- Think about what makes sense for this particular project, not generic templates
- Each day should have a clear purpose and achievable workload
- Build in logical progression from day to day

Return your plan as JSON. Include both:
- "phases": Array of phases with tasks
- "dailyPlans": Array of daily plans, one for each day from $startDateStr to $endDateStr

Example structure:
{
  "phases": [
    {
      "phase_title": "Phase Name",
      "description": "Phase description",
      "tasks": [
        {
          "task_title": "Task name",
          "description": "Task description",
          "estimated_hours": 2.5
        }
      ]
    }
  ],
  "dailyPlans": [
    {
      "date": "YYYY-MM-DD",
      "tasks": [
        {
          "title": "Task to do today",
          "description": "What to do",
          "estimatedHours": 1.5,
          "phase": "Phase name"
        }
      ],
      "totalHours": 2.5,
      "notes": "Focus on..."
    }
  ]
}
''';
  }

  Future<String> _callGeminiAPI(String prompt) async {
    try {
      // Use Flutter Gemini SDK - according to https://pub.dev/documentation/flutter_gemini/3.0.0/#getting-started
      final gemini = Gemini.instance;
      
      // Call the prompt method using Part.text as per documentation
      final response = await gemini.prompt(parts: [
        Part.text(prompt),
      ]);

      // Extract text from response
      final output = response?.output;
      if (output == null || output.isEmpty) {
        throw Exception('Empty response from Gemini API');
      }

      return output;
    } catch (e) {
      // Handle specific errors
      final errorStr = e.toString();
      
      if (errorStr.contains('API key') || errorStr.contains('401') || errorStr.contains('403')) {
        throw Exception(
          'Authentication failed. Please check your API key.\n\n'
          '1. Make sure you\'re using a valid Gemini API key (not an access token)\n'
          '2. Get your API key from: https://makersuite.google.com/app/apikey\n'
          '3. The key should start with "AIza"\n'
          '4. Make sure Gemini.init() is called in main.dart with your API key\n'
          '5. Make sure the API key has access to Gemini API\n\n'
          'Original error: $e'
        );
      }
      
      if (errorStr.contains('quota') || errorStr.contains('429')) {
        throw Exception(
          'API quota exceeded. Please check your usage limits.\n\n'
          '1. Check your quota in Google Cloud Console\n'
          '2. Wait a bit and try again\n'
          '3. Consider upgrading your plan if needed\n\n'
          'Original error: $e'
        );
      }
      
      throw Exception('Failed to call Gemini API: $e');
    }
  }

  ProjectPlan _parseProjectPlan(String responseText) {
    try {
      // Extract JSON from response (handle markdown, whitespace, etc.)
      String jsonText = _extractJsonFromResponse(responseText);
      
      final json = jsonDecode(jsonText) as Map<String, dynamic>;
      
      // AI might structure it differently - try multiple common patterns
      List<dynamic> phasesJson;
      
      if (json.containsKey('phases')) {
        phasesJson = json['phases'] as List<dynamic>;
      } else if (json.containsKey('project_plan') && json['project_plan'] is Map) {
        // Handle nested structure: { "project_plan": { "phases": [...] } }
        final projectPlan = json['project_plan'] as Map<String, dynamic>;
        phasesJson = projectPlan['phases'] as List<dynamic>? ?? [];
      } else if (json.containsKey('plan') && json['plan'] is Map) {
        final plan = json['plan'] as Map<String, dynamic>;
        phasesJson = plan['phases'] as List<dynamic>? ?? [];
      } else if (json.values.first is Map) {
        // Check if first value is a Map that might contain phases
        final firstValue = json.values.first as Map<String, dynamic>;
        if (firstValue.containsKey('phases')) {
          phasesJson = firstValue['phases'] as List<dynamic>;
        } else {
          throw Exception('Could not find phases in AI response structure');
        }
      } else if (json.values.first is List) {
        // Maybe phases are at the root level
        phasesJson = json.values.first as List<dynamic>;
      } else {
        throw Exception('Could not find phases in AI response structure');
      }
      
      final phases = phasesJson.asMap().entries.map((entry) {
        final phaseJson = entry.value;
        
        // Handle different possible structures
        Map<String, dynamic> phase;
        if (phaseJson is Map<String, dynamic>) {
          phase = phaseJson;
        } else if (phaseJson is Map) {
          phase = Map<String, dynamic>.from(phaseJson);
        } else {
          throw Exception('Invalid phase structure');
        }
        
        // Get tasks - handle different possible field names
        List<dynamic> tasksJson = [];
        if (phase.containsKey('tasks')) {
          tasksJson = phase['tasks'] as List<dynamic>;
        } else if (phase.containsKey('taskList')) {
          tasksJson = phase['taskList'] as List<dynamic>;
        } else if (phase.containsKey('items')) {
          tasksJson = phase['items'] as List<dynamic>;
        }
        
        final tasks = tasksJson.map((taskJson) {
          final task = taskJson is Map<String, dynamic> 
              ? taskJson 
              : Map<String, dynamic>.from(taskJson as Map);
          
          // Handle different possible field names for hours
          double hours = 1.0;
          if (task.containsKey('estimatedHours')) {
            hours = (task['estimatedHours'] as num).toDouble();
          } else if (task.containsKey('estimated_hours')) {
            hours = (task['estimated_hours'] as num).toDouble();
          } else if (task.containsKey('hours')) {
            hours = (task['hours'] as num).toDouble();
          } else if (task.containsKey('time')) {
            hours = (task['time'] as num).toDouble();
          }
          
          return PhaseTask(
            title: task['title'] as String? 
                ?? task['task_title'] as String?
                ?? task['name'] as String? 
                ?? 'Untitled Task',
            description: task['description'] as String? ?? task['desc'] as String? ?? '',
            estimatedHours: hours,
          );
        }).toList();
        
        return Phase(
          title: phase['title'] as String? 
              ?? phase['phase_title'] as String?
              ?? phase['name'] as String? 
              ?? 'Untitled Phase',
          description: phase['description'] as String? ?? phase['desc'] as String? ?? '',
          order: phase['order'] as int? ?? phase['sequence'] as int? ?? entry.key + 1,
          tasks: tasks,
        );
      }).toList();
      
      return ProjectPlan(phases: phases);
    } catch (e) {
      throw Exception('Failed to parse AI response: $e. Response was: $responseText');
    }
  }
  
  String _extractJsonFromResponse(String responseText) {
    String jsonText = responseText.trim();
    
    // Remove markdown code blocks if present
    if (jsonText.startsWith('```json')) {
      jsonText = jsonText.substring(7);
    } else if (jsonText.startsWith('```')) {
      jsonText = jsonText.substring(3);
    }
    
    if (jsonText.endsWith('```')) {
      jsonText = jsonText.substring(0, jsonText.length - 3);
    }
    
    // Find JSON object boundaries if there's extra text
    final startIndex = jsonText.indexOf('{');
    final lastIndex = jsonText.lastIndexOf('}');
    
    if (startIndex != -1 && lastIndex != -1 && lastIndex > startIndex) {
      jsonText = jsonText.substring(startIndex, lastIndex + 1);
    }
    
    return jsonText.trim();
  }

}
