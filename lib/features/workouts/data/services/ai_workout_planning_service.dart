import 'dart:convert';
import 'package:flutter/foundation.dart' show debugPrint;
import 'package:flutter_gemini/flutter_gemini.dart';
import '../../../../app/env.dart';
import '../../domain/entities/workout_planning_input.dart';
import '../../domain/repositories/ai_workout_planning_repository.dart';
import '../../domain/entities/workout_plan.dart';
import '../../../../core/models/workout_model.dart' as workout_model;

/// AI Workout Planning Service
/// Uses Flutter Gemini SDK to generate workout plans dynamically based on user input
/// All plans are generated by AI - no hardcoded templates
class AIWorkoutPlanningService implements AIWorkoutPlanningRepository {
  // ============================================================================
  // API KEY CONFIGURATION
  // ============================================================================
  // IMPORTANT: For security, API keys should NEVER be hardcoded in source code.
  // Use environment variables instead:
  // Run with: flutter run --dart-define=GEMINI_API_KEY=your_key_here
  // Get your API key from: https://makersuite.google.com/app/apikey
  // ============================================================================

  /// Get API key for initialization (public static method)
  /// Used by main.dart to initialize Gemini
  /// API key must be provided via --dart-define=GEMINI_API_KEY=your_key
  static String getApiKey() {
    return AppEnv.geminiApiKey;
  }

  static String _getApiKey() {
    return getApiKey();
  }

  @override
  Future<WorkoutPlan> generateWorkoutPlan(WorkoutPlanningInput input) async {
    final apiKey = _getApiKey();
    if (apiKey.isEmpty) {
      throw Exception(
        'Gemini API key is not configured.\n\n'
        'Please set it using environment variables:\n'
        'Run with: flutter run --dart-define=GEMINI_API_KEY=your_key_here\n\n'
        'Get your API key from: https://makersuite.google.com/app/apikey\n\n'
        'Make sure Gemini.init() is called in main.dart!'
      );
    }

    // Gemini should be initialized in main.dart, but verify
    try {
      Gemini.instance;
    } catch (e) {
      // If not initialized, initialize it now
      Gemini.init(apiKey: apiKey, enableDebugging: false);
    }

    final prompt = _buildPrompt(input);
    final response = await _callGeminiAPI(prompt);
    return _parseWorkoutPlan(response);
  }

  /// Generate a WorkoutPlanModel with daily workout sessions using AI
  /// This method generates both weeks/sessions and day-by-day schedule in a single API call
  Future<workout_model.WorkoutPlanModel> generateDailyWorkoutPlan(
    WorkoutPlanningInput input,
    String userId,
  ) async {
    final apiKey = _getApiKey();
    if (apiKey.isEmpty) {
      throw Exception(
        'Gemini API key is not configured.\n\n'
        'Please set it using environment variables:\n'
        'Run with: flutter run --dart-define=GEMINI_API_KEY=your_key_here\n\n'
        'Get your API key from: https://makersuite.google.com/app/apikey\n\n'
        'Make sure Gemini.init() is called in main.dart!'
      );
    }

    // Gemini should be initialized in main.dart, but verify
    try {
      Gemini.instance;
    } catch (e) {
      // If not initialized, initialize it now
      Gemini.init(apiKey: apiKey, enableDebugging: false);
    }

    // Generate both weeks/sessions and daily plans in a single API call
    final prompt = _buildPrompt(input);
    final response = await _callGeminiAPI(prompt);
    
    // Parse daily workout sessions from the single response
    final dailySessions = _parseDailyWorkoutSessionsFromResponse(response, input);
    
    // Calculate dates
    final startDate = DateTime.now();
    final endDate = startDate.add(Duration(days: input.durationWeeks * 7));

    return workout_model.WorkoutPlanModel(
      id: '',
      userId: userId,
      goalType: input.goalType,
      fitnessLevel: input.fitnessLevel,
      durationWeeks: input.durationWeeks,
      sessionsPerWeek: input.sessionsPerWeek,
      minutesPerSession: input.minutesPerSession,
      startDate: startDate,
      endDate: endDate,
      status: 'active',
      equipment: input.equipment,
      constraints: input.constraints,
      workoutDays: dailySessions,
    );
  }

  String _buildPrompt(WorkoutPlanningInput input) {
    final totalSessions = input.durationWeeks * input.sessionsPerWeek;
    final startDate = DateTime.now();
    final endDate = startDate.add(Duration(days: input.durationWeeks * 7));
    final startDateStr = startDate.toString().split(' ')[0];
    final endDateStr = endDate.toString().split(' ')[0];

    final equipmentStr = input.equipment.isEmpty 
        ? 'bodyweight only' 
        : input.equipment.join(', ');
    
    final focusAreasStr = input.bodyFocusAreas != null && input.bodyFocusAreas!.isNotEmpty
        ? input.bodyFocusAreas!.join(', ')
        : 'balanced full-body';

    return '''
You are an expert fitness trainer and workout planning assistant. Create a comprehensive, personalized workout plan with day-by-day breakdown based on the following user preferences:

USER INFORMATION:
- Goal: ${input.goalType}
- Fitness Level: ${input.fitnessLevel}
- Available Equipment: $equipmentStr
- Sessions per Week: ${input.sessionsPerWeek}
- Minutes per Session: ${input.minutesPerSession}
- Duration: ${input.durationWeeks} weeks ($totalSessions total sessions)
- Body Focus Areas: $focusAreasStr
${input.constraints != null && input.constraints!.isNotEmpty ? '- Constraints/Injuries: ${input.constraints}' : ''}
${input.intensityPreference != null ? '- Intensity Preference: ${input.intensityPreference}' : ''}
${input.currentActivityLevel != null ? '- Current Activity Level: ${input.currentActivityLevel}' : ''}

YOUR TASK:
Create a complete workout plan that includes:

1. WEEK-BY-WEEK STRUCTURE: Organize workouts into weeks
   - ${input.durationWeeks} weeks total
   - ${input.sessionsPerWeek} sessions per week
   - Each week should have progressive difficulty
   - Each session should have: title, focus area, and exercises

2. DAY-BY-DAY SCHEDULE: Create a detailed daily schedule
   - Start from $startDateStr and distribute sessions across $endDateStr
   - Each workout day should have:
     * Date (YYYY-MM-DD format)
     * Session title (e.g., "Upper Body Strength", "Cardio & Core")
     * Focus area (e.g., "chest, shoulders, triceps" or "full body")
     * List of exercises with:
       - Exercise name
       - Sets (number of sets)
       - Reps (e.g., "8-12" or "10" or "30s" for time-based)
       - Rest seconds between sets (rest time after completing each set of this exercise)
       - Rest seconds between exercises (rest time after completing all sets of this exercise, before moving to next exercise)
       - Instructions/form tips
     * Total minutes (should be around ${input.minutesPerSession} minutes)
   - Distribute sessions evenly across the weeks
   - Consider rest days and recovery
   - Progress difficulty week by week
   - Match exercises to available equipment: $equipmentStr

IMPORTANT GUIDELINES:
- Make it realistic and achievable for ${input.fitnessLevel} level
- Total sessions should be exactly $totalSessions
- Exercises should be appropriate for the fitness level
- Consider the goal (${input.goalType}) when structuring workouts
- Each session should be complete and actionable
- Include proper warm-up and cool-down recommendations
- Progress intensity and volume over time
- Ensure exercises match available equipment
${input.constraints != null && input.constraints!.isNotEmpty ? '- Avoid exercises that could aggravate: ${input.constraints}' : ''}

Return your plan as JSON. Include both:
- "weeks": Array of weeks with sessions
- "dailySessions": Array of daily workout sessions, one for each scheduled day from $startDateStr to $endDateStr

Example structure:
{
  "weeks": [
    {
      "weekNumber": 1,
      "sessions": [
        {
          "title": "Upper Body Strength",
          "focus": "chest, shoulders, triceps",
          "exercises": [
            {
              "name": "Push Ups",
              "sets": 3,
              "reps": "10-15",
              "restSeconds": 60,
              "restBetweenExercises": 90,
              "instructions": "Maintain a neutral spine and keep elbows at 45¬∞."
            }
          ]
        }
      ]
    }
  ],
  "dailySessions": [
    {
      "date": "YYYY-MM-DD",
      "title": "Upper Body Strength",
      "focus": "chest, shoulders, triceps",
      "exercises": [
        {
          "name": "Push Ups",
          "sets": 3,
          "reps": "10-15",
          "restSeconds": 60,
          "restBetweenExercises": 90,
          "instructions": "Maintain a neutral spine and keep elbows at 45¬∞."
        }
      ],
      "minutes": 30,
      "notes": "Focus on form and controlled movements"
    }
  ]
}
''';
  }

  Future<String> _callGeminiAPI(String prompt) async {
    try {
      debugPrint('ü§ñ Calling Gemini API for workout plan generation...');
      
      final response = await Gemini.instance.prompt(
        parts: [Part.text(prompt)],
      );

      if (response?.output == null || response!.output!.isEmpty) {
        throw Exception('Gemini API returned empty response');
      }

      debugPrint('‚úÖ Received response from Gemini API (${response.output!.length} characters)');
      return response.output!;
    } catch (e) {
      debugPrint('‚ùå Gemini API error: $e');
      
      final errorStr = e.toString().toLowerCase();
      
      if (errorStr.contains('401') || errorStr.contains('unauthorized') || errorStr.contains('unauthenticated')) {
        throw Exception(
          'Gemini API authentication failed.\n\n'
          'Please check:\n'
          '1. Your API key is correct\n'
          '2. The API key is set in ai_workout_planning_service.dart\n'
          '3. Gemini.init() is called in main.dart\n\n'
          'Get your API key from: https://makersuite.google.com/app/apikey\n\n'
          'Original error: $e'
        );
      }
      
      if (errorStr.contains('quota') || errorStr.contains('429')) {
        throw Exception(
          'API quota exceeded. Please check your usage limits.\n\n'
          '1. Check your quota in Google Cloud Console\n'
          '2. Wait a bit and try again\n'
          '3. Consider upgrading your plan if needed\n\n'
          'Original error: $e'
        );
      }
      
      throw Exception('Failed to call Gemini API: $e');
    }
  }

  WorkoutPlan _parseWorkoutPlan(String responseText) {
    try {
      // Extract JSON from response
      String jsonText = _extractJsonFromResponse(responseText);
      final json = jsonDecode(jsonText) as Map<String, dynamic>;
      
      // Find weeks in the response
      List<dynamic> weeksJson;
      
      if (json.containsKey('weeks')) {
        weeksJson = json['weeks'] as List<dynamic>;
      } else if (json.containsKey('workout_plan') && json['workout_plan'] is Map) {
        final workoutPlan = json['workout_plan'] as Map<String, dynamic>;
        weeksJson = workoutPlan['weeks'] as List<dynamic>? ?? [];
      } else if (json.containsKey('plan') && json['plan'] is Map) {
        final plan = json['plan'] as Map<String, dynamic>;
        weeksJson = plan['weeks'] as List<dynamic>? ?? [];
      } else {
        throw Exception('Could not find weeks in AI response structure');
      }
      
      final weeks = weeksJson.map((weekJson) {
        final week = weekJson is Map<String, dynamic> 
            ? weekJson 
            : Map<String, dynamic>.from(weekJson as Map);
        
        final sessionsJson = week['sessions'] as List<dynamic>? ?? [];
        final sessions = sessionsJson.map((sessionJson) {
          final session = sessionJson is Map<String, dynamic>
              ? sessionJson
              : Map<String, dynamic>.from(sessionJson as Map);
          
          final exercisesJson = session['exercises'] as List<dynamic>? ?? [];
          final exercises = exercisesJson.map((exerciseJson) {
            final exercise = exerciseJson is Map<String, dynamic>
                ? exerciseJson
                : Map<String, dynamic>.from(exerciseJson as Map);
            
            // Handle sets - can be number or string like "AMRAP"
            int sets = 3;
            final setsValue = exercise['sets'];
            if (setsValue is num) {
              sets = setsValue.toInt();
            } else if (setsValue is String) {
              // If it's a string like "AMRAP", use default
              sets = 3;
            }
            
            return WorkoutExercise(
              name: exercise['name'] as String? ?? 'Unknown Exercise',
              sets: sets,
              reps: exercise['reps'] as String? ?? '10',
              restSeconds: (exercise['restSeconds'] as num?)?.toInt() ?? 60,
              restBetweenExercises: (exercise['restBetweenExercises'] as num?)?.toInt() ?? 90,
              instructions: exercise['instructions'] as String? ?? '',
            );
          }).toList();
          
          return WorkoutSession(
            title: session['title'] as String? ?? 'Workout Session',
            focus: session['focus'] as String? ?? '',
            exercises: exercises,
          );
        }).toList();
        
        return WorkoutWeek(
          weekNumber: (week['weekNumber'] as num?)?.toInt() ?? 1,
          sessions: sessions,
        );
      }).toList();
      
      return WorkoutPlan(weeks: weeks);
    } catch (e) {
      throw Exception('Failed to parse AI response: $e. Response was: $responseText');
    }
  }

  /// Parse daily workout sessions from a complete response
  List<workout_model.WorkoutDayModel> _parseDailyWorkoutSessionsFromResponse(
    String responseText,
    WorkoutPlanningInput input,
  ) {
    try {
      // Extract JSON from response
      String jsonText = _extractJsonFromResponse(responseText);
      final json = jsonDecode(jsonText) as Map<String, dynamic>;
      
      // Try to find dailySessions in the response
      List<dynamic>? dailySessionsJson;
      
      if (json.containsKey('dailySessions')) {
        dailySessionsJson = json['dailySessions'] as List<dynamic>?;
      } else if (json.containsKey('schedule')) {
        dailySessionsJson = json['schedule'] as List<dynamic>?;
      } else if (json.containsKey('days')) {
        dailySessionsJson = json['days'] as List<dynamic>?;
      } else if (json.containsKey('workoutDays')) {
        dailySessionsJson = json['workoutDays'] as List<dynamic>?;
      }
      
      if (dailySessionsJson != null && dailySessionsJson.isNotEmpty) {
        // Parse the daily sessions array
        return _parseDailySessionsArray(dailySessionsJson, input);
      }
      
      // If no daily sessions found, generate from weeks structure
      return _generateDailySessionsFromWeeks(json, input);
    } catch (e) {
      debugPrint('‚ö†Ô∏è Warning: Could not parse daily sessions from response: $e');
      // Return empty list on error
      return [];
    }
  }
  
  /// Parse an array of daily workout session objects
  List<workout_model.WorkoutDayModel> _parseDailySessionsArray(
    List<dynamic> dailySessionsJson,
    WorkoutPlanningInput input,
  ) {
    final startDate = DateTime.now();
    int sessionCounter = 0;
    
    return dailySessionsJson.asMap().entries.map((entry) {
      final sessionJson = entry.value is Map<String, dynamic> 
          ? entry.value as Map<String, dynamic>
          : Map<String, dynamic>.from(entry.value as Map);
      
      // Parse date - handle different formats
      String dateStr = sessionJson['date'] as String? ?? '';
      DateTime scheduledDate;
      
      if (dateStr.contains('-')) {
        final dateParts = dateStr.split('-');
        scheduledDate = DateTime(
          int.parse(dateParts[0]),
          int.parse(dateParts[1]),
          int.parse(dateParts[2]),
        );
      } else {
        // Distribute sessions evenly across the duration
        final daysBetweenSessions = (7 / input.sessionsPerWeek).ceil();
        if (sessionCounter == 0) {
          scheduledDate = startDate;
        } else {
          scheduledDate = startDate.add(Duration(days: sessionCounter * daysBetweenSessions));
        }
        sessionCounter++;
      }
      
      // Get exercises
      final exercisesJson = sessionJson['exercises'] as List<dynamic>? ?? [];
      final exercises = exercisesJson.asMap().entries.map((exerciseEntry) {
        final exerciseJson = exerciseEntry.value is Map<String, dynamic>
            ? exerciseEntry.value as Map<String, dynamic>
            : Map<String, dynamic>.from(exerciseEntry.value as Map);
        
        // Handle sets - can be number or string like "AMRAP"
        int sets = 3;
        final setsValue = exerciseJson['sets'];
        if (setsValue is num) {
          sets = setsValue.toInt();
        } else if (setsValue is String) {
          // If it's a string like "AMRAP", use default
          sets = 3;
        }
        
        return workout_model.WorkoutExerciseModel(
          id: '',
          workoutDayId: '',
          name: exerciseJson['name'] as String? ?? 'Unknown Exercise',
          sets: sets,
          reps: exerciseJson['reps'] as String? ?? '10',
          restSeconds: (exerciseJson['restSeconds'] as num?)?.toInt() ?? 60,
          restBetweenExercises: (exerciseJson['restBetweenExercises'] as num?)?.toInt() ?? 90,
          instructions: exerciseJson['instructions'] as String? ?? '',
          equipment: input.equipment.isNotEmpty ? input.equipment.first : 'bodyweight',
          intensityLevel: input.fitnessLevel == 'beginner' 
              ? 'easy' 
              : input.fitnessLevel == 'advanced' 
                  ? 'hard' 
                  : 'medium',
        );
      }).toList();
      
      // Calculate week number
      final weekNumber = ((scheduledDate.difference(startDate).inDays / 7).floor() + 1)
          .clamp(1, input.durationWeeks);
      
      return workout_model.WorkoutDayModel(
        id: '',
        planId: '',
        weekNumber: weekNumber,
        dayLabel: sessionJson['title'] as String? ?? 'Workout Session',
        scheduledDate: scheduledDate,
        focus: sessionJson['focus'] as String? ?? '',
        order: entry.key + 1,
        minutes: (sessionJson['minutes'] as num?)?.toInt() ?? input.minutesPerSession,
        exercises: exercises,
      );
    }).toList();
  }

  /// Generate daily sessions from weeks structure if dailySessions not provided
  List<workout_model.WorkoutDayModel> _generateDailySessionsFromWeeks(
    Map<String, dynamic> json,
    WorkoutPlanningInput input,
  ) {
    final startDate = DateTime.now();
    final weeksJson = json['weeks'] as List<dynamic>? ?? [];
    final sessions = <workout_model.WorkoutDayModel>[];
    int sessionCounter = 0;
    final daysBetweenSessions = (7 / input.sessionsPerWeek).ceil();
    
    for (var weekJson in weeksJson) {
      final week = weekJson is Map<String, dynamic> 
          ? weekJson 
          : Map<String, dynamic>.from(weekJson as Map);
      
      final weekNumber = (week['weekNumber'] as num?)?.toInt() ?? 1;
      final sessionsJson = week['sessions'] as List<dynamic>? ?? [];
      
      for (var sessionJson in sessionsJson) {
        final session = sessionJson is Map<String, dynamic>
            ? sessionJson
            : Map<String, dynamic>.from(sessionJson as Map);
        
        final scheduledDate = startDate.add(Duration(days: sessionCounter * daysBetweenSessions));
        
        final exercisesJson = session['exercises'] as List<dynamic>? ?? [];
        final exercises = exercisesJson.asMap().entries.map((exerciseEntry) {
          final exercise = exerciseEntry.value is Map<String, dynamic>
              ? exerciseEntry.value as Map<String, dynamic>
              : Map<String, dynamic>.from(exerciseEntry.value as Map);
          
          // Handle sets - can be number or string like "AMRAP"
          int sets = 3;
          final setsValue = exercise['sets'];
          if (setsValue is num) {
            sets = setsValue.toInt();
          } else if (setsValue is String) {
            // If it's a string like "AMRAP", use default
            sets = 3;
          }
          
          return workout_model.WorkoutExerciseModel(
            id: '',
            workoutDayId: '',
            name: exercise['name'] as String? ?? 'Unknown Exercise',
            sets: sets,
            reps: exercise['reps'] as String? ?? '10',
            restSeconds: (exercise['restSeconds'] as num?)?.toInt() ?? 60,
            restBetweenExercises: (exercise['restBetweenExercises'] as num?)?.toInt() ?? 90,
            instructions: exercise['instructions'] as String? ?? '',
            equipment: input.equipment.isNotEmpty ? input.equipment.first : 'bodyweight',
            intensityLevel: input.fitnessLevel == 'beginner' 
                ? 'easy' 
                : input.fitnessLevel == 'advanced' 
                    ? 'hard' 
                    : 'medium',
          );
        }).toList();
        
        sessions.add(workout_model.WorkoutDayModel(
          id: '',
          planId: '',
          weekNumber: weekNumber,
          dayLabel: session['title'] as String? ?? 'Workout Session',
          scheduledDate: scheduledDate,
          focus: session['focus'] as String? ?? '',
          order: sessionCounter + 1,
          minutes: input.minutesPerSession,
          exercises: exercises,
        ));
        
        sessionCounter++;
      }
    }
    
    return sessions;
  }
  
  String _extractJsonFromResponse(String responseText) {
    String jsonText = responseText.trim();
    
    // Remove markdown code blocks if present
    if (jsonText.startsWith('```json')) {
      jsonText = jsonText.substring(7);
    } else if (jsonText.startsWith('```')) {
      jsonText = jsonText.substring(3);
    }
    
    if (jsonText.endsWith('```')) {
      jsonText = jsonText.substring(0, jsonText.length - 3);
    }
    
    // Find JSON object boundaries if there's extra text
    final startIndex = jsonText.indexOf('{');
    final lastIndex = jsonText.lastIndexOf('}');
    
    if (startIndex != -1 && lastIndex != -1 && lastIndex > startIndex) {
      jsonText = jsonText.substring(startIndex, lastIndex + 1);
    }
    
    return jsonText.trim();
  }
}
